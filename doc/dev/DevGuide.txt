
========================
MetPX Contributors Guide
========================

:Authors:
    Peter Silva
    Daniel Lemay

:Version: $Revision: $
:Copyright: 
    MetPX Copyright (C) 2004-2006  Environment Canada.
    MetPX comes with ABSOLUTELY NO WARRANTY; For details type see the file
    named COPYING in the root of the source directory tree.
    


.. contents::


Starting Out
------------
This manual describes ideal working methods we strive for.
Sometimes we do not manage to live up to our ideals.
If you find parts of the code that do not follow the prescriptions here,
then it is either an oversight or code which existed before this guide
was created.  Please strive to follow the guide's principles.


Getting Source Code
-------------------

svn co etc...


Development Environment
-----------------------

 * dpkg -i first, then re-direct via symlinks
 * svn co (either anonymous, or with your user name.)
 * alternative, run with PXROOT setting.
 * Set up a loopback test environment, as per the User Guide.
 * Add what you need to test your features on top of the basic loop back.


Contributing
-------------

 * read this manual !
 * propose about what is to be done on metpx-devel.
 * do not add configuration options without discussion.
 * consider performance when adding features.
 * Apply Python Style Guide (even though some of the existing modules do not.)
 * Comments in the code should say what the goal of code is, rather than how it is being done (code itself says how.)
       example to avoid (similar spots in the code in multiple places):
		# process the bulletin
                self.processBulletin()

 * to become a project member email peter_silva@users.sourceforge.net
    * probably will want to see some sample fixes, submitted as patches first.

 * once you have commit privileges:
 * Commit early, commit often.
 * commit only working code.  Occasional breakage is normal, but try to avoid.
   when committing code:
   * svn up 
   * run a loopback test (read the logs to confirm basic functionality is still there.)
   * everything is OK?  clean up
   * svn up again, to make sure nothing else happenned.
   * svn commit.
 
		




Efficiency Considerations
--------------------------


First Principle: Each message is stored in one file
-----------------------------------------------------

The first application design principle is to use files as an application 
storage method.  The contention is that storing messages in files 
provides sufficient performance, and will make the application 
simpler to implement, and generally applicable to a unification of
traditionally short messages and larger items as RADAR or satellite data 
for switching purposes.  


Second Principle: Avoid IPC
----------------------------

combined with the above principle is to a principle of eliminating 
other forms of inter-process communications (IPC) relying only on the inherent 
locking provided by the file system.  If there is a lock in an algorithm, 
then that indicates where there are race conditions or potential 
contention.  The application is to be designed such that no such 
conditions arise, and avoid the need for performance altering synchronization.

for example:  
   -- a message is received, all messages/files received are to have unique
      names such that there are no name clashes.
   -- Since there are no name clashes, all processes can place files
      into the database and client queues in parallel.  Since there are
      no queues which need to be explicitly added to by the programs,
      there is no IPC needed to moderate access to the queues (five
      sources can simultaneously be adding items to a single client queue)
   -- serialization of access to file system directories is taken care of by 
      operating system mechanisms, no code is required to support them.
      As these mechanisms are already heavily used, their reliability is assumed.   


Third Principle: Minimize file system interactions
----------------------------------------------------

Even if file system performance has been deemed adequate, it has still been as 
the element which dominates the performance of the application, so optimization 
of interactions with the file system may provide significant benefits.

examples:

   * If we can pack all the routing information in the name, 
     we are better off. (avoid a stat call per file to route.)
     example here: better to have an ascii encoded date in the file name
     than perform a stat call.  (FIXME: TEST THIS!)

   * Want to minimize the number of times we touch a file
     initial creation (open), close (commits all writes), link, unlink, chmod.

   * PDS method of file protection (chmod 000 during xfer) is more
     expensive than renaming (FIXME: TEST THIS!)
     FIXME: wanted test confirming/denying the cost of these calls.

   * file and directory manipulation time is directly proportional to the
     lengths of the file names. (FIXME: reference long file name results.)
     so do not lengthen them beyond what you need.

   * When there is more than a few tens of thousands  of files in a 
     single directory, it becomes cumbersome to manage.  Plan out the
     directory tree to avoid having directories which exceed 100,000
     entries. (FIXME: figure out the test data to back this up.)


Fourth Principle:  No performance coding based on assumptions without experimental proof.
-----------------------------------------------------------------------------------------

To examine performance, make some guesses.  Then make some small test programs
to verify the guesses.   Keep the testing hypothesis, and the test
done to verify it.  If the results make sense, then start looking at
how to modify things to be in accordance with the hypothesis.


have a sample test below:

-----------------------------------------------------------------

test #1: efficiency of date calls. PS
I was worried calls to format strings of the time would be 
expensive, because on some systems, they are (stupidly acquire a lock
to read the time, makes stuff slow.) wrote a loop below to try it out:


|
| import time
| 
| t=time.time()
| i=0
| den=100000
| while i < den:
|   tl=time.time()
|   today = time.strftime( "%Y%m%d", time.gmtime(tl) )
|   i=i+1
| 
| print tl, t, den, (tl-t)/den
|

-------------------------------------------------------------------

and ran it on my laptop (linux 2.6.10 from kernel.org.) :
1106969450.64 1106969449.84 100000 8.01682949066e-06

in other words, it takes 8 microseconds per loop iteration.  So if performance 
is limited to a few hundred or even a few thousand calls per second (as is 
likely the case), then this call will account for only 0.1 % of execution time.  
Not worth optimizing.  Avoids having to wonder when to check if the date changed.  

FIXME: have not looked at system overhead of these calls.


tests wanted:
For whatever priority schemes we come up with, need to have methods
to verify their behaviour in revovery situations...

 * large numbers of files, with lower priorities, and
 * and small numbers of files with high priorities.

review results for messages per second, and data.

  * our normal peak 5/second
  * application rate few hundred per second.
  * recovery from failure is the performance driver.


-------------------------------------------------------------------

2005-02-09 (DL)

Note: These tests have been done on my personal computer, not a server.

A filename verification function has been added to the directory sorting
ingestor. The pattern to verify is written as a regex.

The verification is not included directly in the class that extracts the "keys"
from a filename. It implies that a first pass has to be done to eliminate the
"bad" files. It's better for the design and the overhead is negligible.

Testing has been done on ingestion of 12000 filenames. Here are the results:

Time to ingest the 12000 filenames: ~16 seconds
Time to verify the correctness of each filename: ~ 1 second
Time to sort the good filenames (12000): ~ 1 second

Conclusion: The time spent for name verification is negligible in comparison
to the time passed to ingest.

=> We choose design over performance on this item.

-------------------------------------------------------------------

2005-03-01 (DL)

Tests have been done on pds5.

We were able to create 20000 links in 0.75 second. This observation has
for consequence that we have let down worklists.

-------------------------------------------------------------------

2005-03-01 (DL)

Tests have been done on pds5.

The tests consist in reading and validating filenames contained in a
directory and sorting the filenames (according to priority and timestamp). 


============= =================== =============
Number of     Time for reading    Sorting 
files         and validating      Time
              filenames   
============= =================== =============
20000         ~ 1 sec             ~ 1 sec
40000         ~ 3 sec             ~ 1 sec
200000        ~ 15 sec            ~ 8 sec
------------- ------------------- -------------
100000        ~ 29 sec            ~ 4 sec
200000        ~ 60 sec            ~ 8 sec
------------- ------------------- -------------
100000        ~ 26 sec            ~ 4 sec
200000        ~ 52 sec            ~ 8 sec
------------- ------------------- -------------
40000         ~ 3 sec             ~ 1 sec
100000        ~ 7 sec             ~ 4 sec
200000        ~ 15 sec            ~ 7 sec
============= =================== =============


Conclusion: Il semble y avoir linearite dans le reading et le sorting. Les
temps de sorting sont extremement constants (25000 files/second). Les temps
de reading dependent du load de la machine. Meme si ce load n'est pas vraiment
perceptible par la commande uptime. Dans tous les cas presentes ci-haut, le load
(tel que vu dans uptime) etait tres bas (moins de 1). Le taux de reading varie
entre 3333 files/seconde et 13333 files/seconde.



Useful stuff
--------------


| initial file hierarchy:
|         PX_ROOT= /apps/px
| 	PX_ROOT/db/<date>/
| 	PX_ROOT/rxq/<source>/[1..5]_<YYYYMMDDHH>
| 	PX_ROOT/txq/<client>/[1..5]_<YYYYMMDDHH>
|       PX_ROOT/log/rx_<source>
|       PX_ROOT/log/tx_<client>
|        PX_ROOT/log/trx_<sourlient>
|        
|        PX_ROOT/etc/
|		px.conf
|		pxRouting.conf
|		stations.conf
|	        tx/<client>.conf
|	        trx/<sourlient>.conf
|		rx/<reception>.conf


Map of Source Code
-------------------

What all the files are doing, generally, in the source...

================= ==========================================================================================
 path	          Explanation
================= ==========================================================================================
bin/              All the runnable scripts

                  px          : Send a command (start, stop, reload, status) to all receivers and senders
                  pxReceiver  : Send a command (start, stop, reload, status) to a receiver
                  pxSender    : Send a command (start, stop, reload, status) to a sender
                  pxTranceiver : Send a command (start, stop, reload, status) to a Transceiver 
                  (Tranceivers are rare... only there for AFTN.)
                  paplat      : Used to make latencies stats
                  pxChecker   : Restart a sender/receiver that should be running (cron each minute)
                  pxDBCleaner : Keep a certain amount of days in DB (cron each day)
----------------- ------------------------------------------------------------------------------------------
etc/              Configuration files for senders and receivers are put there
                  etc/rx/titi.conf  (example for a receiver)
                  etc/tx/toto.conf  (example for a sender)
                  pxRouting.conf (direct routing file)
                  stations.conf (map stations to bulletin headers (for collections & header completion.)
                  px.conf - sitewide settings, such as default extension, user names, PXROOT, etc...
----------------- ------------------------------------------------------------------------------------------
[r,t]xq/ 
                  Reception queues:     rxq/titi/  (example for a source titi)
                  Transmission queues:  txq/toto/3/2005110815/ (example for a client toto)
----------------- ------------------------------------------------------------------------------------------
db/               The database.
                  The file SAUY_SUMU_280100_00005:nws-alph:SUMU:SA:5:Direct:20051107210952
                  will be put in /apps/px/db/20051107/SA/nws-alph/SUMU/
----------------- ------------------------------------------------------------------------------------------
/apps/px/log/     Log files.
                  Log of source titi: /apps/px/log/rx_titi.log
                  Log of client toto: /apps/px/log/tx_toto.log
================= ==========================================================================================

The scripts in bin are basically stubs which all the appropriate routines in the lib directory.
The guts of the application are in lib.   Here is an introduction to the 

============================  ============================================================
Purpose                       Files
----------------------------  ------------------------------------------------------------
Bulletin Processing           bulletin.py
                              bulletinPlain.py
                              bulletinAm.py
                              bulletinWmo.py
                              bulletinManager.py
                              bulletinManagerAm.py
                              bulletinManagerWmo.py
----------------------------  ------------------------------------------------------------
Socket Management             socketManager.py
                              socketManagerAm.py
                              socketManagerWmo.py
----------------------------  ------------------------------------------------------------
General utilities             PDSPaths.py         : Useful paths for PDS   
                              PXPaths.py          : Useful paths for PX
                              SystemManager.py   
                              PDSManager.py
                              PXManager.py
                              CacheManager.py
                              Logger.py
                              mailLib.py
                              dateLib.py
----------------------------  ------------------------------------------------------------
Start, stop, restart, reload  Igniter.py
                              PXIgniter.py
----------------------------  ------------------------------------------------------------
Receivers and Senders         gateway.py
                              receiverAm.py
                              receiverWmo.py
                              senderAm.py
                              senderWmo.py
                              senderAMIS.py
                              SenderFTP.py
----------------------------  ------------------------------------------------------------
Configuration file parsing    Client.py
and ingestion                 Source.py
                              Ingestor.py
                              URLParser.py
----------------------------  ------------------------------------------------------------
Reading and Sorting           DiskReader.py
                              SortableString.py
                              StandardSorter.py
                              MultiKeysStringSorter.py
----------------------------  ------------------------------------------------------------
Switchover Procedure          SwitchoverCopier.py
                              SwitchoverDeleter.py
----------------------------  ------------------------------------------------------------
paplat                        LatMessage.py
                              Latencies.py
                              PXLatencies.py
                              PDSLatencies.py
                              Plotter.py
----------------------------  ------------------------------------------------------------
AFTN                          MessageAFTN.py
                              MessageManager.py
                              TransceiverAFTN.py
                              TextSplitter.py
============================  ============================================================





Terminology/Glossary
--------------------


Circuits
     Circuits are established relationships with other machines.
     Circuits are unidirectional and can be divided into two types:
     We receive products from 'source' circuits and deliver products
     to 'client' circuits.   For bi-directional connections, the trx
     configuration directory includes 'sourlient' circuit definitions.
   
     The term circuit is used loosely, as in this case it applies
     to file reception and delivery as well as traditional permanent
     connections.
   
Directions
     all directions are relative to the entire machine, not any sub-component.
     if files are on their way into the machine, they are rx (reception) files.
     if they are on their way out from the machine, they are tx (transmission) files.
   
     sample confusion to be avoided:
     ie. in PDS, the 'incoming' directory is where one places files which are outgoing from the server,
     because they are 'incoming' to the client.  Such a directory name is very confusing.
     in PX, the analogous files are under the transmit txq directory hierarchy.

Clients
     locations to which products are delivered.
     same terminology as the PDS.

sources 
     one (or more, depends on priority setting in config.)
     places where files can be received.

Sourlient
     Combined source & client... Tranceiver type channels.  Bi-directional.

Reception Name
     Files are received with a "reception name" in the rxq.
     To the reception name, receivers typically add an extension, to create
     the ingest name.

Ingest Name
     Ingest name is used to store the file in the DB, as is.

     for soon to be deprecated patterned routing (see below):
     ingest name is mapped against patterns to find clients who 
     will be sent the file.

Destination File Name
     destination file name, destfn, is calculated:
     default is first field of ingest name.
     add suffixes according to DESTFN parameter setting in pattern.

Version1 Routing
     combines Direct Routing with patterns and caching...
     coming soon (version1/rx_algorithm.txt)

Direct Routing
     routing using a lookup table, tandem style, with direct correspondence
     between source and client.  Used by almost all receivers.

Pattern Routing
     traditional PDS routing, via emasks & imasks
     Single-file receiver accurately reproduces PDS routing.
     just looks at imasks/emasks in clients.  Expect latencies to grow 
     longer as more clients and patterns are added to a configuration.
     This method is to be deprecated in favour of the, as yet only in
     discussion phase, version1/rx_algorithm.txt

Derived Products, Filters, Transformations, post_ingest_processing
     once a product has been received, create another one based on it. 


