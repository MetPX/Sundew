#!/usr/bin/env python
"""
MetPX Copyright (C) 2004-2006  Environment Canada
MetPX comes with ABSOLUTELY NO WARRANTY; For details type see the file 
named COPYING in the root of the source directory tree.

#############################################################################################
# Name: pxValidator
#
# Author: Daniel Lemay
#
# Date: 2006-04-28
#
# Description: This program is used to validate the routing table and the station table. 
# 
#############################################################################################
"""

import os, sys, getopt
sys.path.insert(1, sys.path[0] + '/../lib')
sys.path.insert(1,sys.path[0] + '/../lib/importedLibs')

import PXPaths
from Logger import Logger
from PXManager import PXManager
from StationParser import StationParser
from DirectRoutingParser import DirectRoutingParser

def usage():
    print "\nUsage: pxValidator [-f filename] where filename is the name of the direct routing file"
    print "ex 1: pxValidator  (default filename is PXPaths.ETC/header2client.conf)"
    print "ex 2: pxValidator -f header2client.conf (defaut path is PXPaths.ETC)"
    print "ex 3: pxValidator -f /toto/tutu/head.conf\n"

class PXValidator:
    LOG_LEVEL = "INFO"      # Logging level
    filename = None

    def __init__(self):

        PXPaths.normalPaths()
        self.manager = PXManager()
        LOG_NAME = self.manager.LOG + 'pxValidator.log'    # Log's name
        logger = Logger(LOG_NAME, PXValidator.LOG_LEVEL, "Validator")

        self.getOptionsParser()
        self.logger = logger.getLogger()
        self.manager.setLogger(self.logger)

        self.drp = DirectRoutingParser(PXValidator.filename)
        self.sp = StationParser(PXPaths.STATION_TABLE)

    def printMenu(self):
        print
        print("1-Clients indexed by header")
        print("2-Headers indexed by station")
        print("3-Stations indexed by header")
        print("4-AFTN addresses indexed by header")
        print("m-Reprint this menu")
        print("q-Quit")
        print

    def interrogate(self):
        self.printMenu()
        mustChoose = True
        selector = {'1': 'header', 
                    '2': 'station',
                    '3': 'header',
                    '4': 'header',
                   }

        while True:
            if mustChoose:
                mode = raw_input("Your choice: ")
                if mode in ['1', '2', '3', '4']:
                    pass
                elif mode == 'm' or mode == 'M':
                    self.printMenu()
                    continue
                elif mode == 'q' or mode == 'Q': sys.exit()
                else:
                    print "Bad choice!"
                    self.printMenu()
                    continue
                mustChoose = False

            print
            answer = raw_input("Enter a %s:  " % selector[mode]).upper()
            if answer == 'Q' or answer == '': sys.exit()
            elif answer == 'M':
                self.printMenu()
                mustChoose = True
                continue

            if mode == '1':
                if self.drp.routingInfos.get(answer, None) is None:
                    print("%s is not in the table" % answer)
                else:
                    print self.drp.routingInfos[answer]['clients']
            elif mode == '2':
                print self.sp.headers.get(answer, "%s is not in the table" % answer)
            elif mode == '3':
                print self.sp.stations.get(answer, "%s is not in the table" % answer)
            elif mode == '4':
                if self.drp.routingInfos.get(answer, None) is None:
                    print("%s is not in the table" % answer)
                elif self.drp.routingInfos[answer]['subclients'].get('aftn', None) is None:
                    print("aftn client is not in the table for this header")
                else:
                    print self.drp.routingInfos[answer]['subclients']['aftn']
        
    def validate(self):
        print "################################################################"
        print "#                       Routing Table Errors                   #"
        print "################################################################"
        self.drp.parseAndShowErrors()
        print "################################################################"
        print "#                       Station Table Errors                   #"
        print "################################################################"
        self.sp.printErrors = True
        self.sp.parse()
        #self.sp.printInfos()
        print "##########################END###################################"

    def getOptionsParser(self):
        filename = False

        try:
            opts, args = getopt.getopt(sys.argv[1:], 'f:h', ['help', 'filename='])
            #print "Options:%s" % opts
            #print "Args:%s" % args
            if args:
                usage()
                sys.exit(2)
        except getopt.GetoptError:
            # print help information and exit:
            usage()
            sys.exit(2)

        for option, value in opts:
            if option in ('-h', '--help'):
                usage()
                sys.exit()
            if option in ('-f', '--filename'):
                filename = True
                if os.path.dirname(value):
                    PXValidator.filename = value
                else:
                    PXValidator.filename = PXPaths.ETC + value

        if filename  is False:
            PXValidator.filename = PXPaths.ETC + 'header2client.conf'

if __name__ == '__main__':

    validator =  PXValidator()
    validator.validate()
    validator.interrogate()
    #print "The program successfully ended"
