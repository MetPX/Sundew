#!/usr/bin/env python
"""
MetPX Copyright (C) 2004-2006  Environment Canada
MetPX comes with ABSOLUTELY NO WARRANTY; For details type see the file 
named COPYING in the root of the source directory tree.

#############################################################################################
# Name: pxValidator
#
# Author: Daniel Lemay
#
# Date: 2006-04-28
#
# Description: This program is used to validate the routing table and the station table. 
# 
#############################################################################################
"""

import os, sys, getopt
sys.path.insert(1, sys.path[0] + '/../lib')
sys.path.insert(1,sys.path[0] + '/../lib/importedLibs')

import PXPaths
from Logger import Logger
from PXManager import PXManager
from StationParser import StationParser
from DirectRoutingParser import DirectRoutingParser

def usage():
    print "\nUsage: pxValidator [-r routing] [-s stations] where routing is"
    print "the name of the routing file and stations is the name of the stations file\n"
    print "ex 1: pxValidator  (default routing is PXPaths.ROUTING_TABLE and default stations is PXPaths.STATION_TABLE)"
    print "ex 2: pxValidator -r pxRouting.conf (defaut path is PXPaths.ETC)"
    print "ex 3: pxValidator -r /toto/tutu/pxRouting.conf\n"

class PXValidator:
    LOG_LEVEL = "INFO"      # Logging level
    routingFilename = None
    stationsFilename = None

    def __init__(self):

        PXPaths.normalPaths()
        self.manager = PXManager()
        LOG_NAME = self.manager.LOG + 'pxValidator.log'    # Log's name
        logger = Logger(LOG_NAME, PXValidator.LOG_LEVEL, "Validator")

        self.getOptionsParser()
        self.logger = logger.getLogger()
        self.manager.setLogger(self.logger)

        self.drp = DirectRoutingParser(PXValidator.routingFilename)
        self.sp = StationParser(PXValidator.stationsFilename)
        #self.sp = StationParser(PXPaths.STATION_TABLE)

    def printMenu(self):
        print
        print("1-Clients indexed by header")
        print("2-Headers indexed by station")
        print("3-Stations indexed by header")
        print("4-Stations indexed by collected header")
        print("5-AFTN addresses indexed by header")
        print("m-Reprint this menu (to make another choice)")
        print("q-Quit")
        print

    def interrogate(self):
        self.printMenu()
        mustChoose = True
        selector = {'1': 'header', 
                    '2': 'station',
                    '3': 'header',
                    '4': 'collected header',
                    '5': 'header',
                   }

        while True:
            if mustChoose:
                mode = raw_input("Your choice: ")
                if mode in ['1', '2', '3', '4', '5']:
                    pass
                elif mode == 'm' or mode == 'M':
                    self.printMenu()
                    continue
                elif mode == 'q' or mode == 'Q': sys.exit()
                else:
                    print "Bad choice!"
                    self.printMenu()
                    continue
                mustChoose = False

            print
            answer = raw_input("Enter a %s:  " % selector[mode]).upper()
            if answer == 'Q' or answer == '': sys.exit()
            elif answer == 'M':
                self.printMenu()
                mustChoose = True
                continue

            if mode == '1':
                if self.drp.routingInfos.get(answer, None) is None:
                    print("%s is not in the table" % answer)
                else:
                    print self.drp.routingInfos[answer]['clients']
            elif mode == '2':
                print self.sp.headers.get(answer, "%s is not in the table" % answer)
            elif mode == '3':
                print self.sp.stations.get(answer, "%s is not in the table" % answer)
            elif mode == '4':
                print self.sp.stationsColl.get(answer, "%s is not collected (or not in the table)" % answer)
            elif mode == '5':
                if self.drp.routingInfos.get(answer, None) is None:
                    print("%s is not in the table" % answer)
                elif self.drp.routingInfos[answer]['subclients'].get('aftn', None) is None:
                    print("aftn client is not in the table for this header")
                else:
                    print self.drp.routingInfos[answer]['subclients']['aftn']
        
    def validate(self):
        print "################################################################"
        print "# Routing Table (%s) Errors" % PXValidator.routingFilename
        print "################################################################"
        self.drp.parseAndShowErrors()
        print "################################################################"
        print "# Station Table (%s) Errors" % PXValidator.stationsFilename
        print "################################################################"
        self.sp.printErrors = True
        self.sp.parse()
        #self.sp.printInfos()
        print "##########################END###################################"

        print "\nNOTE: The following menu has NOTHING to do with automatic validation"
        print "If you're only interested in validation results, type q (to quit)."

    def getOptionsParser(self):
        routingFilename = False
        stationsFilename = False

        try:
            opts, args = getopt.getopt(sys.argv[1:], 'r:s:h', ['help', 'routing=', 'stations='])
            #print "Options:%s" % opts
            #print "Args:%s" % args
            if args:
                usage()
                sys.exit(2)
        except getopt.GetoptError:
            # print help information and exit:
            usage()
            sys.exit(2)

        for option, value in opts:
            if option in ('-h', '--help'):
                usage()
                sys.exit()

            # Routing 
            if option in ('-r', '--routing'):
                routingFilename = True
                if os.path.dirname(value):
                    PXValidator.routingFilename = value
                else:
                    PXValidator.routingFilename = PXPaths.ETC + value

            # Stations
            if option in ('-s', '--stations'):
                stationsFilename = True
                if os.path.dirname(value):
                    PXValidator.stationsFilename = value
                else:
                    PXValidator.stationsFilename = PXPaths.ETC + value

        if routingFilename  is False:
            PXValidator.routingFilename = PXPaths.ROUTING_TABLE

        if stationsFilename is False:
            PXValidator.stationsFilename = PXPaths.STATION_TABLE


if __name__ == '__main__':

    validator =  PXValidator()
    validator.validate()
    validator.interrogate()
    #print "The program successfully ended"
