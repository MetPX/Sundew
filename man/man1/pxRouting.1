.TH PX "1" "May 2007" "px 1.0.0" "Metpx suite"
.SH NAME
pxRouting \- Definition : how data travels between Metpx processes
.SH DESCRIPTION
.Pp
METPX defines \fBrouting\fR as the means to define how data must travel through its processes.
A more practical way of looking at it is how a received product will be sent to the proper clients.

The programs that initiate routing are the one receiving data namely: receivers, filters and
transceivers. The routing algorithm is the same for all of them.  For simplicity,
throughout this document we will use a receiver as the routing initiator.

The data is routed to processes such as filters, transceivers and senders.
There is an exception. Receivers could route the data to another the receiver using the
\fBfeed\fR option.  For simplicity, we will use senders as the routing's end target.

When a receiver starts (or reloads), the tasks it reads his configuration file, it loads a routing table (optional
for some processes) and parses the configuration of all senders available in the METPX installation'state.
creating a list of active senders.  Then there are 2 ways of achieving the routing of incoming products:
.nf

.B     1- Using accept/reject in the processes'configuration. (imask/emask)
.B     2- Using a product routing table (must use one when receiving bulletins from socket)
.B        in combination with (1)

.fi
Details on each item follow.
.SH USING ACCEPT/REJECT IN PROCESSES'CONFIGURATION
.Pp
For this part, we assume that no routing table is used by the receiver.
In that case, the routing is solely done through a few configuration options.
They are :
.nf

patternMatching boolean  (Default: True)
accept <regexp pattern>
reject <regexp pattern>
emask <filepattern>
imask <filepattern>
clientsPatternMatching boolean  (Default: True)

\fBThe reception :\fR

.fi
When a receiver has received a product, it determines the filename that the product will be given.
By convention that filename is called the ingestName.  If the receiver option 
\fBpatternMatching\fR is set to True, the ingestName is matched against the
\fBaccept\fR and \fBreject\fR regexp patterns of the receiver's configuration file.  
The default is for the file to be accepted.  \fBreject\fR can be used to suppress reception 
of files with a certain pattern. Files suppressed are not ingested into the DB and they are not 
routed any further. If the product is accepted, go on with the next step.
.nf

\fBThe determination of the senders :\fR

.fi
When no routing table is used, the receiver considers for each product the list of active senders
built at startup (reload). 
.nf

\fBThe delivery part :\fR

.fi
If the receiver option \fBclientsPatternMatching\fR is set to False, then the product is linked
to all senders of the list.  If the option \fBclientsPatternMatching\fR is set to True, the ingestName
is matched against the \fBaccept\fR and \fBreject\fR regexp patterns of each of the senders in the list.
The product will be routed to a sender only if it matches one of its \fBaccept (imask)\fR options without
having matched to a \fBreject (emask)\fR previously.

.SH USING A PRODUCT ROUTING TABLE
Depending on implementation (if your METPX implementation has 200 senders for example) the delivery part
(where routing each product considers all senders) becomes a performance issue. It is more efficient to
have a direct association between a product and its list of interested senders. This idea is 
implemented as the routing table.

Basically, the routing table is a table indexed by "product keys". To each "product key"
is associated two informations : the product's priority and the product's list of interested
senders.  More details in the pxRoutingTable manual.

When a routing table is used, the reception and delivery part remain the same as discussed above.
The determination of senders is of course different. The receiver has to go through the following
different steps:

\fBThe product key generation :\fR

.fi
The receiver derives from the product received a "product key".
For bulletins, the key generated is T1T2A1A1ii_CCCC (see wmo bulletin definition). 
For example SACN31_CWAO.

For anything else, the key is the ingestName (filename given to the incoming product)
without its datetime reception suffix.

There are cases where the ingestName has unstable parts. The ingestName as is, cannot be a
constant product key hence routing becomes impossible. In this case, the \fBaccept\fR option
is instrumented to pick the parts of the ingestName and create a stable product key.
You just have to put into parenthesis the parts that you want to keep in the product key.
Enclosed regular expression are kept too. If more than one part are selected, the key 
will be the concatenation of the parts separeted by underscore. For example :

          accept .*(txt:AQ).*(:AIRNOW:.*:ASCII)
          ingestName = 20070515.txt:AQ1245Z:AIRNOW:CMQ:ASCII
          the product key generated will be txt:AQ_:AIRNOW:CMQ:ASCII

.nf

\fBThe senders list generation :\fR

.fi

Once the "product key" generated, the routing table is adressed with it.
If the product key is not found, the product is databased and its routing stops.
The receiver logs a warning saying that  key "X" generated from "ingestName"
is not defined.

When the "product key" is found, the routing table provides to the receiver 
the product's associated list of senders and priority.  A sender is considered
for that product if and only if this sender is present in the routing table list
and the active sender list created at startup (reload).

The considered senders will go through the normal delivery part as explained above.
Once a receiver has determined that a sender should transmit a product, it writes
the products in its transmission directory tree...  
namely under $PXROOT/txq/"sender_name"/priority/YYYYMMDDHH where YYYYMMDDHH is the current
date time. The priority is the one found in the routing table.
